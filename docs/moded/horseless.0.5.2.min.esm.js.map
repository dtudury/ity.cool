{"version":3,"file":"horseless.0.5.2.min.esm.js","sources":["../node_modules/horseless.decoder/lib/basicDecoders.js","../node_modules/horseless.decoder/decoder.js","../node_modules/horseless.remodel/remodel.js","../lib/domBuilder.js","../lib/mappers.js"],"sourcesContent":["export function assertChar (arr, regex) {\n  if (!arr[arr.i].match(regex)) {\n    throw new Error(`expected ${regex}. got ${arr[arr.i]} at i=${arr.i}`)\n  }\n  arr.i++\n}\n\nexport function readValue (arr) {\n  if (arr[arr.i].isValue) {\n    return arr[arr.i++]\n  }\n}\n\nexport function readEscaped (arr) {\n  assertChar(arr, /&/)\n  if (readIf(arr, 'amp;')) {\n    return '&'\n  } else if (readIf(arr, 'apos;')) {\n    return '\\''\n  } else if (readIf(arr, 'gt;')) {\n    return '>'\n  } else if (readIf(arr, 'lt;')) {\n    return '<'\n  } else if (readIf(arr, 'quot;')) {\n    return '\"'\n  } else {\n    throw new Error('unhandled escape sequence')\n  }\n}\n\nexport function readTo (arr, regex) {\n  const ss = []\n  while (arr.i < arr.length) {\n    const c = arr[arr.i]\n    if (c.isValue || c.match(regex)) {\n      return ss.join('')\n    } else if (c === '&') {\n      ss.push(readEscaped(arr))\n    } else {\n      ss.push(c)\n      arr.i++\n    }\n  }\n  return ss.join('')\n}\n\nexport function skipWhiteSpace (arr) {\n  readTo(arr, /\\S/)\n}\n\nexport function readIf (arr, str) {\n  if (!str.length) {\n    str = [str]\n  }\n  const out = []\n  for (let i = 0; i < str.length; i++) {\n    const char = arr[arr.i + i]\n    if (!char || !char.match || !char.match(str[i])) {\n      return false\n    }\n    out.push(char)\n  }\n  arr.i += str.length\n  return out.join('')\n}\n","import { skipWhiteSpace, readTo, readValue, readEscaped, assertChar, readIf } from './lib/basicDecoders.js'\n\nconst _voidElements = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'])\nconst END = Symbol('end')\n\nfunction _readValueParts (arr, regex) {\n  const out = []\n  let ss = []\n  while (arr.i < arr.length) {\n    const c = arr[arr.i]\n    if (c.isValue) {\n      if (ss.length) {\n        out.push({ type: 'part', value: ss.join('') })\n        ss = []\n      }\n      out.push(c.value)\n      arr.i++\n    } else if (c.match(regex)) {\n      if (ss.length) {\n        out.push({ type: 'part', value: ss.join('') })\n      }\n      return out\n    } else if (c === '&') {\n      ss.push(readEscaped(arr))\n    } else {\n      ss.push(c)\n      arr.i++\n    }\n  }\n}\n\nfunction _decodeAttribute (arr) {\n  skipWhiteSpace(arr)\n  const c = arr[arr.i]\n  if (c === '/' || c === '>') {\n    return END\n  }\n  let name = readValue(arr)\n  if (name && name.isValue) {\n    return name.value\n  }\n  name = readTo(arr, /[\\s=/>]/)\n  if (!name) {\n    throw new Error('attribute must have a name (dynamic attributes okay, dynamic names... sorry)')\n  }\n  skipWhiteSpace(arr)\n  const equalSign = readIf(arr, '=')\n  if (equalSign) {\n    skipWhiteSpace(arr)\n    let value = readValue(arr)\n    if (value) {\n      value = value.value\n    } else {\n      const quote = readIf(arr, /['\"]/)\n      if (quote) {\n        value = _readValueParts(arr, quote)\n        assertChar(arr, quote)\n      } else {\n        value = readTo(arr, /[\\s=/>]/)\n      }\n    }\n    return { type: 'attribute', name, value }\n  } else {\n    return { type: 'attribute', name }\n  }\n}\n\nfunction _decodeAttributes (arr) {\n  const attributes = []\n  while (true) {\n    const attribute = _decodeAttribute(arr)\n    if (attribute !== END) {\n      attributes.push(attribute)\n    } else {\n      return attributes\n    }\n  }\n}\n\nfunction _decodeTag (arr) {\n  skipWhiteSpace(arr)\n  const c = arr[arr.i]\n  if (c.isValue) {\n    arr.i++\n    return c.value\n  }\n  return readTo(arr, /[\\s/>]/)\n}\n\nfunction _decodeElement (arr) {\n  const c = arr[arr.i]\n  if (c.isValue) {\n    arr.i++\n    return c.value\n  } else if (c === '<') {\n    assertChar(arr, /</)\n    const isClosing = readIf(arr, '/')\n    const tag = _decodeTag(arr)\n    const isVoid = _voidElements.has(tag)\n    const attributes = _decodeAttributes(arr)\n    const isEmpty = readIf(arr, '/') || isVoid\n    assertChar(arr, />/)\n    const children = (isClosing || isEmpty) ? [] : _decodeElements(arr, tag)\n    if (isVoid && isClosing) return null\n    return { type: 'node', tag, attributes, children, isClosing }\n  } else {\n    return { type: 'textnode', value: readTo(arr, /</) }\n  }\n}\n\nfunction _decodeElements (arr, closingTag) {\n  const nodes = []\n  while (arr.i < arr.length) {\n    const node = _decodeElement(arr)\n    if (node != null) {\n      if (node.isClosing) {\n        if (closingTag != null) {\n          return nodes\n        }\n      } else {\n        delete node.isClosing\n        nodes.push(node)\n      }\n    }\n  }\n  return [].concat.apply([], nodes)\n}\n\nexport function h (strings, ...values) {\n  const ss = [strings[0].split('')]\n  for (let i = 0; i < values.length; i++) {\n    ss.push({ value: values[i], isValue: true })\n    ss.push(strings[i + 1].split(''))\n  }\n  const arr = [].concat.apply([], ss)\n  arr.i = 0\n  return _decodeElements(arr, null)\n}\n","/* global requestAnimationFrame */\nconst _proxySet = new Set()\nconst _keyMaps = new Map()\nconst _triggerable = new Set()\nconst _triggered = new Set()\nconst _stack = []\nconst _afterTriggered = []\nconst _OWN_KEYS = Symbol('ownKeys as attribute')\nlet _handlingTriggered = false\n\nfunction _reportKeyMutation (target, key) {\n  if (_keyMaps.has(key)) {\n    const keyMap = _keyMaps.get(key)\n    if (keyMap.has(target)) {\n      if (!_handlingTriggered) {\n        _handlingTriggered = true\n        requestAnimationFrame(() => {\n          _handlingTriggered = false\n          for (const callback of _triggered) {\n            callback()\n          }\n          _triggered.clear()\n          while (_afterTriggered.length) {\n            _afterTriggered.shift()()\n          }\n        })\n      }\n      for (const callback of keyMap.get(target)) {\n        _triggered.add(callback)\n      }\n      keyMap.delete(target)\n      if (!keyMap.size) {\n        _keyMaps.delete(key)\n      }\n    }\n  }\n}\n\nfunction _reportKeyAccess (target, key) {\n  if (_stack.length) {\n    if (!_keyMaps.has(key)) {\n      _keyMaps.set(key, new Map())\n    }\n    const keyMap = _keyMaps.get(key)\n    if (!keyMap.has(target)) {\n      keyMap.set(target, new Set())\n    }\n    keyMap.get(target).add(_stack[0])\n  }\n}\n\nexport function proxy (target = {}) {\n  if (target instanceof Object && !_proxySet.has(target)) {\n    const _self = new Proxy(Array.isArray(target) ? new Array(target.length) : {}, {\n      has (target, key) {\n        _reportKeyAccess(target, key)\n        return key in target\n      },\n      get (target, key) {\n        _reportKeyAccess(target, key)\n        return target[key]\n      },\n      set (target, key, value) {\n        value = proxy(value)\n        if (target[key] !== value || key === 'length') { // array length is magical\n          if (!(key in target)) {\n            _reportKeyMutation(target, _OWN_KEYS)\n          }\n          _reportKeyMutation(target, key)\n        }\n        target[key] = value\n        return true\n      },\n      deleteProperty (target, key) {\n        if (key in target) {\n          _reportKeyMutation(target, _OWN_KEYS)\n          _reportKeyMutation(target, key)\n        }\n        return Reflect.deleteProperty(target, key)\n      },\n      ownKeys (target) {\n        _reportKeyAccess(target, _OWN_KEYS)\n        return Reflect.ownKeys(target)\n      }\n    })\n    Object.assign(_self, target)\n    _proxySet.add(_self)\n    target = _self\n  }\n  return target\n}\n\nexport function watchFunction (f) {\n  function wrapped () {\n    if (_triggerable.has(f)) {\n      _stack.unshift(wrapped)\n      f()\n      _stack.shift()\n    }\n  }\n  if (!_triggerable.has(f)) {\n    _triggerable.add(f)\n    wrapped()\n  }\n}\n\nexport function unwatchFunction (f) {\n  _triggerable.delete(f)\n}\n\nexport function after (f) {\n  _afterTriggered.push(f)\n}\n","import { watchFunction } from './remodel.js'\n\nfunction _constructValue (parts, node) {\n  if (parts == null) return null\n  if (typeof parts === 'function') {\n    parts = parts(node)\n  }\n  if (Array.isArray(parts)) {\n    const mappedParts = parts.map(part => {\n      if (typeof part === 'function') {\n        part = part(node)\n      }\n      if (part == null) return ''\n      if (part && part.type === 'part') {\n        return part.value\n      } else {\n        return part\n      }\n    })\n    if (mappedParts.length === 1) {\n      return mappedParts[0]\n    }\n    return mappedParts.join('')\n  }\n  return parts\n}\n\nfunction _renderAttributes (attributes, node) {\n  let obj = {}\n  attributes.forEach(attribute => {\n    if (typeof attribute === 'function') {\n      attribute = attribute(node)\n    }\n    if (attribute == null) return\n    if (attribute && attribute.type === 'attribute') {\n      const name = attribute.name\n      if (Object.prototype.hasOwnProperty.call(obj, name)) return\n      const value = _constructValue(attribute.value, node)\n      if (value == null) {\n        obj[name] = name\n      } else {\n        obj[name] = value\n      }\n    } else if (Array.isArray(attribute)) {\n      obj = Object.assign(_renderAttributes(attribute, node), obj)\n    } else if (typeof attribute === 'object') {\n      Object.entries(attribute).forEach(([name, value]) => {\n        if (Object.prototype.hasOwnProperty.call(obj, name)) return\n        obj[name] = value\n      })\n    } else {\n      const name = attribute.toString()\n      if (Object.prototype.hasOwnProperty.call(obj, name)) return\n      obj[name] = name\n    }\n  })\n  return obj\n}\n\nfunction _setAttribute (element, name, value) {\n  if (element[name] !== value) {\n    try {\n      element[name] = value\n    } catch (e) {\n      // SVGs don't like getting their properties set and that's okay...\n    }\n  }\n  if (!(typeof value).match(/(?:boolean|number|string)/)) {\n    value = name\n  }\n  const str = value.toString()\n  if (element.getAttribute(name) !== str) {\n    element.setAttribute(name, str)\n  }\n  return element\n}\n\nfunction _setAttributes (element, attributes) {\n  Object.entries(attributes).forEach(([name, value]) => {\n    _setAttribute(element, name, value)\n  })\n  return element\n}\n\nfunction _pruneAttributes (element, newAttributes, oldAttributes) {\n  const orphans = new Set(Object.keys(oldAttributes))\n  Object.keys(newAttributes).forEach(attribute => orphans.delete(attribute))\n  orphans.forEach(attribute => {\n    element.removeAttribute(attribute)\n    delete element[attribute]\n  })\n}\n\nconst _descriptionMap = new Map()\nfunction _descriptionsToNodes (descriptions, xmlns) {\n  if (!Array.isArray(descriptions)) {\n    descriptions = [descriptions]\n  }\n  const nodes = []\n  descriptions.forEach(description => {\n    if (typeof description === 'function') {\n      description = description()\n    }\n    if (description != null) {\n      if (Array.isArray(description)) {\n        nodes.push(..._descriptionsToNodes(description, xmlns))\n      } else {\n        if (description.tag === null || description.tag === '') {\n          nodes.push(..._descriptionsToNodes(description.children, xmlns))\n        } else if (typeof description.tag === 'function') {\n          const attributes = _renderAttributes(description.attributes)\n          nodes.push(..._descriptionsToNodes(description.tag(attributes, description.children, description), attributes.xmlns || xmlns))\n        } else if (description.type) {\n          if (!_descriptionMap.has(description)) {\n            let node\n            if (description.type === 'textnode') {\n              node = document.createTextNode(description.value)\n            } else {\n              let oldAttributes = {}\n              let newAttributes = _renderAttributes(description.attributes, node)\n              watchFunction(() => {\n                newAttributes = _renderAttributes(description.attributes, node)\n                if (node) {\n                  _setAttributes(node, newAttributes)\n                  _pruneAttributes(node, newAttributes, oldAttributes)\n                  oldAttributes = newAttributes\n                }\n              })\n              node = document.createElementNS(newAttributes.xmlns || xmlns, description.tag, { is: newAttributes.is })\n              _setAttributes(node, newAttributes)\n              render(node, description.children, newAttributes.xmlns || xmlns)\n            }\n            _descriptionMap.set(description, node)\n          }\n          nodes.push(_descriptionMap.get(description))\n        } else {\n          nodes.push(document.createTextNode(description.toString()))\n        }\n      }\n    }\n  })\n  return nodes\n}\n\nfunction _setChildren (element, descriptions, xmlns) {\n  const newNodes = _descriptionsToNodes(descriptions, xmlns)\n  newNodes.forEach((newNode, index) => {\n    while (element.childNodes[index] !== newNode) {\n      const oldNode = element.childNodes[index]\n      if (!oldNode) {\n        element.appendChild(newNode)\n      } else if (newNodes.indexOf(oldNode) > index) {\n        element.insertBefore(newNode, oldNode)\n      } else {\n        element.removeChild(oldNode)\n      }\n    }\n  })\n  while (element.childNodes.length > newNodes.length) {\n    element.removeChild(element.lastChild)\n  }\n  return element\n}\n\nexport function render (element, descriptions, xmlns = 'http://www.w3.org/1999/xhtml') {\n  if (!descriptions) {\n    return _descriptionsToNodes(element, xmlns)\n  }\n  function f () {\n    return _setChildren(element, descriptions, xmlns)\n  }\n  watchFunction(f)\n}\n","// takes a function that evaluates to true or false and static if and else responses. return function that evaluates condition and returns appropriate response\nexport function showIfElse (condition, a, b = []) {\n  return () => condition() ? a : b\n}\n\n// takes an object and a mapping-function. returns a function that maps the object through the function and returns previously calculated mappings on future calls\nexport function mapEntries (object, f) {\n  const map = new Map()\n  return () => {\n    const o = (typeof object === 'function' ? object() : object) || {}\n    map.forEach(indexedValues => {\n      indexedValues.index = 0\n    })\n    const mappedEntries = Object.entries(o).map(([name, value]) => {\n      if (!map.has(value)) {\n        map.set(value, { index: 0, values: [] })\n      }\n      const indexedValues = map.get(value)\n      if (indexedValues.values.length <= indexedValues.index) {\n        indexedValues.values.push(f(value, name))\n      }\n      return indexedValues.values[indexedValues.index++]\n    })\n    // cleanup any unmapped-to values\n    map.forEach((indexedValues, key) => {\n      if (indexedValues.index) {\n        indexedValues.values.splice(indexedValues.index)\n      } else {\n        map.delete(key)\n      }\n    })\n    return mappedEntries\n  }\n}\n\nexport function mapSwitch (expression, f) {\n  const map = new Map()\n  return () => {\n    const expr = expression()\n    if (!map.has(expr)) {\n      map.set(expr, f(expr))\n    }\n    return map.get(expr)\n  }\n}\n\nexport function objToDeclarations (obj = {}) {\n  return Object.entries(obj).map(([name, value]) => `${name}: ${value};`).join('')\n}\n"],"names":["assertChar","arr","regex","i","match","Error","readValue","isValue","readEscaped","readIf","readTo","ss","length","c","join","push","skipWhiteSpace","str","out","char","_voidElements","Set","END","Symbol","_decodeAttribute","name","value","quote","type","_readValueParts","_decodeElement","isClosing","tag","_decodeTag","isVoid","has","attributes","attribute","_decodeAttributes","isEmpty","children","_decodeElements","closingTag","nodes","node","concat","apply","h","strings","values","split","_proxySet","_keyMaps","Map","_triggerable","_triggered","_stack","_afterTriggered","_OWN_KEYS","_handlingTriggered","_reportKeyMutation","target","key","keyMap","get","requestAnimationFrame","callback","clear","shift","add","delete","size","_reportKeyAccess","set","proxy","Object","_self","Proxy","Array","isArray","deleteProperty","Reflect","ownKeys","assign","watchFunction","f","wrapped","unshift","unwatchFunction","after","_renderAttributes","obj","forEach","prototype","hasOwnProperty","call","parts","mappedParts","map","part","_constructValue","entries","toString","_setAttributes","element","e","getAttribute","setAttribute","_setAttribute","_descriptionMap","_descriptionsToNodes","descriptions","xmlns","description","document","createTextNode","oldAttributes","newAttributes","orphans","keys","removeAttribute","_pruneAttributes","createElementNS","is","render","newNodes","newNode","index","childNodes","oldNode","indexOf","insertBefore","removeChild","appendChild","lastChild","_setChildren","showIfElse","condition","a","b","mapEntries","object","o","indexedValues","mappedEntries","splice","mapSwitch","expression","expr","objToDeclarations"],"mappings":"AAAO,SAASA,EAAYC,EAAKC,GAC/B,IAAKD,EAAIA,EAAIE,GAAGC,MAAMF,GACpB,MAAM,IAAIG,MAAM,YAAYH,UAAcD,EAAIA,EAAIE,WAAWF,EAAIE,KAEnEF,EAAIE,IAGC,SAASG,EAAWL,GACzB,GAAIA,EAAIA,EAAIE,GAAGI,QACb,OAAON,EAAIA,EAAIE,KAIZ,SAASK,EAAaP,GAE3B,GADAD,EAAWC,EAAK,KACZQ,EAAOR,EAAK,QACd,MAAO,IACF,GAAIQ,EAAOR,EAAK,SACrB,MAAO,IACF,GAAIQ,EAAOR,EAAK,OACrB,MAAO,IACF,GAAIQ,EAAOR,EAAK,OACrB,MAAO,IACF,GAAIQ,EAAOR,EAAK,SACrB,MAAO,IAEP,MAAM,IAAII,MAAM,6BAIb,SAASK,EAAQT,EAAKC,GAC3B,MAAMS,EAAK,GACX,KAAOV,EAAIE,EAAIF,EAAIW,QAAQ,CACzB,MAAMC,EAAIZ,EAAIA,EAAIE,GAClB,GAAIU,EAAEN,SAAWM,EAAET,MAAMF,GACvB,OAAOS,EAAGG,KAAK,IACA,MAAND,EACTF,EAAGI,KAAKP,EAAYP,KAEpBU,EAAGI,KAAKF,GACRZ,EAAIE,KAGR,OAAOQ,EAAGG,KAAK,IAGV,SAASE,EAAgBf,GAC9BS,EAAOT,EAAK,MAGP,SAASQ,EAAQR,EAAKgB,GACtBA,EAAIL,SACPK,EAAM,CAACA,IAET,MAAMC,EAAM,GACZ,IAAK,IAAIf,EAAI,EAAGA,EAAIc,EAAIL,OAAQT,IAAK,CACnC,MAAMgB,EAAOlB,EAAIA,EAAIE,EAAIA,GACzB,IAAKgB,IAASA,EAAKf,QAAUe,EAAKf,MAAMa,EAAId,IAC1C,OAAO,EAETe,EAAIH,KAAKI,GAGX,OADAlB,EAAIE,GAAKc,EAAIL,OACNM,EAAIJ,KAAK,IC7DlB,MAAMM,EAAgB,IAAIC,IAAI,CAAC,OAAQ,OAAQ,KAAM,MAAO,QAAS,KAAM,MAAO,QAAS,OAAQ,OAAQ,QAAS,SAAU,QAAS,QACjIC,EAAMC,OAAO,OA4BnB,SAASC,EAAkBvB,GACzBe,EAAef,GACf,MAAMY,EAAIZ,EAAIA,EAAIE,GAClB,GAAU,MAANU,GAAmB,MAANA,EACf,OAAOS,EAET,IAAIG,EAAOnB,EAAUL,GACrB,GAAIwB,GAAQA,EAAKlB,QACf,OAAOkB,EAAKC,MAGd,GADAD,EAAOf,EAAOT,EAAK,YACdwB,EACH,MAAM,IAAIpB,MAAM,gFAIlB,GAFAW,EAAef,GACGQ,EAAOR,EAAK,KACf,CACbe,EAAef,GACf,IAAIyB,EAAQpB,EAAUL,GACtB,GAAIyB,EACFA,EAAQA,EAAMA,UACT,CACL,MAAMC,EAAQlB,EAAOR,EAAK,QACtB0B,GACFD,EAlDR,SAA0BzB,EAAKC,GAC7B,MAAMgB,EAAM,GACZ,IAAIP,EAAK,GACT,KAAOV,EAAIE,EAAIF,EAAIW,QAAQ,CACzB,MAAMC,EAAIZ,EAAIA,EAAIE,GAClB,GAAIU,EAAEN,QACAI,EAAGC,SACLM,EAAIH,KAAK,CAAEa,KAAM,OAAQF,MAAOf,EAAGG,KAAK,MACxCH,EAAK,IAEPO,EAAIH,KAAKF,EAAEa,OACXzB,EAAIE,QACC,CAAA,GAAIU,EAAET,MAAMF,GAIjB,OAHIS,EAAGC,QACLM,EAAIH,KAAK,CAAEa,KAAM,OAAQF,MAAOf,EAAGG,KAAK,MAEnCI,EACQ,MAANL,EACTF,EAAGI,KAAKP,EAAYP,KAEpBU,EAAGI,KAAKF,GACRZ,EAAIE,OA6BM0B,CAAgB5B,EAAK0B,GAC7B3B,EAAWC,EAAK0B,IAEhBD,EAAQhB,EAAOT,EAAK,WAGxB,MAAO,CAAE2B,KAAM,YAAaH,KAAAA,EAAMC,MAAAA,GAElC,MAAO,CAAEE,KAAM,YAAaH,KAAAA,GA0BhC,SAASK,EAAgB7B,GACvB,MAAMY,EAAIZ,EAAIA,EAAIE,GAClB,GAAIU,EAAEN,QAEJ,OADAN,EAAIE,IACGU,EAAEa,MACJ,GAAU,MAANb,EAAW,CACpBb,EAAWC,EAAK,KAChB,MAAM8B,EAAYtB,EAAOR,EAAK,KACxB+B,EAlBV,SAAqB/B,GACnBe,EAAef,GACf,MAAMY,EAAIZ,EAAIA,EAAIE,GAClB,OAAIU,EAAEN,SACJN,EAAIE,IACGU,EAAEa,OAEJhB,EAAOT,EAAK,UAWLgC,CAAWhC,GACjBiC,EAASd,EAAce,IAAIH,GAC3BI,EAhCV,SAA4BnC,GAC1B,MAAMmC,EAAa,GACnB,OAAa,CACX,MAAMC,EAAYb,EAAiBvB,GACnC,GAAIoC,IAAcf,EAGhB,OAAOc,EAFPA,EAAWrB,KAAKsB,IA2BCC,CAAkBrC,GAC/BsC,EAAU9B,EAAOR,EAAK,MAAQiC,EACpClC,EAAWC,EAAK,KAChB,MAAMuC,EAAYT,GAAaQ,EAAW,GAAKE,EAAgBxC,EAAK+B,GACpE,OAAIE,GAAUH,EAAkB,KACzB,CAAEH,KAAM,OAAQI,IAAAA,EAAKI,WAAAA,EAAYI,SAAAA,EAAUT,UAAAA,GAElD,MAAO,CAAEH,KAAM,WAAYF,MAAOhB,EAAOT,EAAK,MAIlD,SAASwC,EAAiBxC,EAAKyC,GAC7B,MAAMC,EAAQ,GACd,KAAO1C,EAAIE,EAAIF,EAAIW,QAAQ,CACzB,MAAMgC,EAAOd,EAAe7B,GAC5B,GAAY,MAAR2C,EACF,GAAIA,EAAKb,WACP,GAAkB,MAAdW,EACF,OAAOC,cAGFC,EAAKb,UACZY,EAAM5B,KAAK6B,GAIjB,MAAO,GAAGC,OAAOC,MAAM,GAAIH,GAGtB,SAASI,EAAGC,KAAYC,GAC7B,MAAMtC,EAAK,CAACqC,EAAQ,GAAGE,MAAM,KAC7B,IAAK,IAAI/C,EAAI,EAAGA,EAAI8C,EAAOrC,OAAQT,IACjCQ,EAAGI,KAAK,CAAEW,MAAOuB,EAAO9C,GAAII,SAAS,IACrCI,EAAGI,KAAKiC,EAAQ7C,EAAI,GAAG+C,MAAM,KAE/B,MAAMjD,EAAM,GAAG4C,OAAOC,MAAM,GAAInC,GAEhC,OADAV,EAAIE,EAAI,EACDsC,EAAgBxC,EAAK,MCvI9B,MAAMkD,EAAY,IAAI9B,IAChB+B,EAAW,IAAIC,IACfC,EAAe,IAAIjC,IACnBkC,EAAa,IAAIlC,IACjBmC,EAAS,GACTC,EAAkB,GAClBC,EAAYnC,OAAO,wBACzB,IAAIoC,GAAqB,EAEzB,SAASC,EAAoBC,EAAQC,GACnC,GAAIV,EAASjB,IAAI2B,GAAM,CACrB,MAAMC,EAASX,EAASY,IAAIF,GAC5B,GAAIC,EAAO5B,IAAI0B,GAAS,CACjBF,IACHA,GAAqB,EACrBM,sBAAsB,KACpBN,GAAqB,EACrB,IAAK,MAAMO,KAAYX,EACrBW,IAGF,IADAX,EAAWY,QACJV,EAAgB7C,QACrB6C,EAAgBW,OAAhBX,MAIN,IAAK,MAAMS,KAAYH,EAAOC,IAAIH,GAChCN,EAAWc,IAAIH,GAEjBH,EAAOO,OAAOT,GACTE,EAAOQ,MACVnB,EAASkB,OAAOR,KAMxB,SAASU,EAAkBX,EAAQC,GACjC,GAAIN,EAAO5C,OAAQ,CACZwC,EAASjB,IAAI2B,IAChBV,EAASqB,IAAIX,EAAK,IAAIT,KAExB,MAAMU,EAASX,EAASY,IAAIF,GACvBC,EAAO5B,IAAI0B,IACdE,EAAOU,IAAIZ,EAAQ,IAAIxC,KAEzB0C,EAAOC,IAAIH,GAAQQ,IAAIb,EAAO,KAI3B,SAASkB,EAAOb,EAAS,IAC9B,GAAIA,aAAkBc,SAAWxB,EAAUhB,IAAI0B,GAAS,CACtD,MAAMe,EAAQ,IAAIC,MAAMC,MAAMC,QAAQlB,GAAU,IAAIiB,MAAMjB,EAAOjD,QAAU,GAAI,CAC7EuB,IAAI,CAAC0B,EAAQC,KACXU,EAAiBX,EAAQC,GAClBA,KAAOD,GAEhBG,IAAI,CAACH,EAAQC,KACXU,EAAiBX,EAAQC,GAClBD,EAAOC,IAEhBW,IAAI,CAACZ,EAAQC,EAAKpC,KAChBA,EAAQgD,EAAMhD,GACVmC,EAAOC,KAASpC,GAAiB,WAARoC,IACrBA,KAAOD,GACXD,EAAmBC,EAAQH,GAE7BE,EAAmBC,EAAQC,IAE7BD,EAAOC,GAAOpC,GACP,GAETsD,eAAe,CAACnB,EAAQC,KAClBA,KAAOD,IACTD,EAAmBC,EAAQH,GAC3BE,EAAmBC,EAAQC,IAEtBmB,QAAQD,eAAenB,EAAQC,IAExCoB,QAASrB,IACPW,EAAiBX,EAAQH,GAClBuB,QAAQC,QAAQrB,MAG3Bc,OAAOQ,OAAOP,EAAOf,GACrBV,EAAUkB,IAAIO,GACdf,EAASe,EAEX,OAAOf,EAGF,SAASuB,EAAeC,GAQxB/B,EAAanB,IAAIkD,KACpB/B,EAAae,IAAIgB,GARnB,SAASC,IACHhC,EAAanB,IAAIkD,KACnB7B,EAAO+B,QAAQD,GACfD,IACA7B,EAAOY,SAKTkB,IAIG,SAASE,EAAiBH,GAC/B/B,EAAagB,OAAOe,GAGf,SAASI,EAAOJ,GACrB5B,EAAgB1C,KAAKsE,GCpFvB,SAASK,EAAmBtD,EAAYQ,GACtC,IAAI+C,EAAM,GA4BV,OA3BAvD,EAAWwD,QAAQvD,IAIjB,GAHyB,mBAAdA,IACTA,EAAYA,EAAUO,IAEP,MAAbP,EACJ,GAAIA,GAAgC,cAAnBA,EAAUT,KAAsB,CAC/C,MAAMH,EAAOY,EAAUZ,KACvB,GAAIkD,OAAOkB,UAAUC,eAAeC,KAAKJ,EAAKlE,GAAO,OACrD,MAAMC,EAnCZ,SAA0BsE,EAAOpD,GAC/B,GAAa,MAAToD,EAAe,OAAO,KAI1B,GAHqB,mBAAVA,IACTA,EAAQA,EAAMpD,IAEZkC,MAAMC,QAAQiB,GAAQ,CACxB,MAAMC,EAAcD,EAAME,IAAIC,IACR,mBAATA,IACTA,EAAOA,EAAKvD,IAEF,MAARuD,EAAqB,GACrBA,GAAsB,SAAdA,EAAKvE,KACRuE,EAAKzE,MAELyE,IAGX,OAA2B,IAAvBF,EAAYrF,OACPqF,EAAY,GAEdA,EAAYnF,KAAK,IAE1B,OAAOkF,EAaWI,CAAgB/D,EAAUX,MAAOkB,GAE7C+C,EAAIlE,GADO,MAATC,EACUD,EAEAC,OAET,GAAIoD,MAAMC,QAAQ1C,GACvBsD,EAAMhB,OAAOQ,OAAOO,EAAkBrD,EAAWO,GAAO+C,QACnD,GAAyB,iBAAdtD,EAChBsC,OAAO0B,QAAQhE,GAAWuD,QAAQ,EAAEnE,EAAMC,MACpCiD,OAAOkB,UAAUC,eAAeC,KAAKJ,EAAKlE,KAC9CkE,EAAIlE,GAAQC,SAET,CACL,MAAMD,EAAOY,EAAUiE,WACvB,GAAI3B,OAAOkB,UAAUC,eAAeC,KAAKJ,EAAKlE,GAAO,OACrDkE,EAAIlE,GAAQA,KAGTkE,EAqBT,SAASY,EAAgBC,EAASpE,GAIhC,OAHAuC,OAAO0B,QAAQjE,GAAYwD,QAAQ,EAAEnE,EAAMC,OAnB7C,SAAwB8E,EAAS/E,EAAMC,GACrC,GAAI8E,EAAQ/E,KAAUC,EACpB,IACE8E,EAAQ/E,GAAQC,EAChB,MAAO+E,YAIE/E,GAAOtB,MAAM,+BACxBsB,EAAQD,GAEV,MAAMR,EAAMS,EAAM4E,WACdE,EAAQE,aAAajF,KAAUR,GACjCuF,EAAQG,aAAalF,EAAMR,GAO3B2F,CAAcJ,EAAS/E,EAAMC,KAExB8E,EAYT,MAAMK,EAAkB,IAAIxD,IAC5B,SAASyD,EAAsBC,EAAcC,GACtClC,MAAMC,QAAQgC,KACjBA,EAAe,CAACA,IAElB,MAAMpE,EAAQ,GA2Cd,OA1CAoE,EAAanB,QAAQqB,IAInB,GAH2B,mBAAhBA,IACTA,EAAcA,KAEG,MAAfA,EACF,GAAInC,MAAMC,QAAQkC,GAChBtE,EAAM5B,QAAQ+F,EAAqBG,EAAaD,SAEhD,GAAwB,OAApBC,EAAYjF,KAAoC,KAApBiF,EAAYjF,IAC1CW,EAAM5B,QAAQ+F,EAAqBG,EAAYzE,SAAUwE,SACpD,GAA+B,mBAApBC,EAAYjF,IAAoB,CAChD,MAAMI,EAAasD,EAAkBuB,EAAY7E,YACjDO,EAAM5B,QAAQ+F,EAAqBG,EAAYjF,IAAII,EAAY6E,EAAYzE,SAAUyE,GAAc7E,EAAW4E,OAASA,SAClH,GAAIC,EAAYrF,KAAM,CAC3B,IAAKiF,EAAgB1E,IAAI8E,GAAc,CACrC,IAAIrE,EACJ,GAAyB,aAArBqE,EAAYrF,KACdgB,EAAOsE,SAASC,eAAeF,EAAYvF,WACtC,CACL,IAAI0F,EAAgB,GAChBC,EAAgB3B,EAAkBuB,EAAY7E,WAAYQ,GAC9DwC,EAAc,KACZiC,EAAgB3B,EAAkBuB,EAAY7E,WAAYQ,GACtDA,IACF2D,EAAe3D,EAAMyE,GAvCvC,SAA2Bb,EAASa,EAAeD,GACjD,MAAME,EAAU,IAAIjG,IAAIsD,OAAO4C,KAAKH,IACpCzC,OAAO4C,KAAKF,GAAezB,QAAQvD,GAAaiF,EAAQhD,OAAOjC,IAC/DiF,EAAQ1B,QAAQvD,IACdmE,EAAQgB,gBAAgBnF,UACjBmE,EAAQnE,KAmCDoF,CAAiB7E,EAAMyE,EAAeD,GACtCA,EAAgBC,KAGpBzE,EAAOsE,SAASQ,gBAAgBL,EAAcL,OAASA,EAAOC,EAAYjF,IAAK,CAAE2F,GAAIN,EAAcM,KACnGpB,EAAe3D,EAAMyE,GACrBO,EAAOhF,EAAMqE,EAAYzE,SAAU6E,EAAcL,OAASA,GAE5DH,EAAgBpC,IAAIwC,EAAarE,GAEnCD,EAAM5B,KAAK8F,EAAgB7C,IAAIiD,SAE/BtE,EAAM5B,KAAKmG,SAASC,eAAeF,EAAYX,eAKhD3D,EAuBT,SAAgBiF,EAAQpB,EAASO,EAAcC,EAAQ,gCACrD,IAAKD,EACH,OAAOD,EAAqBN,EAASQ,GAKvC5B,GAHA,WACE,OAzBJ,SAAuBoB,EAASO,EAAcC,GAC5C,MAAMa,EAAWf,EAAqBC,EAAcC,GAapD,IAZAa,EAASjC,QAAQ,CAACkC,EAASC,KACzB,KAAOvB,EAAQwB,WAAWD,KAAWD,GAAS,CAC5C,MAAMG,EAAUzB,EAAQwB,WAAWD,GAC9BE,EAEMJ,EAASK,QAAQD,GAAWF,EACrCvB,EAAQ2B,aAAaL,EAASG,GAE9BzB,EAAQ4B,YAAYH,GAJpBzB,EAAQ6B,YAAYP,MAQnBtB,EAAQwB,WAAWpH,OAASiH,EAASjH,QAC1C4F,EAAQ4B,YAAY5B,EAAQ8B,WAE9B,OAAO9B,EAQE+B,CAAa/B,EAASO,EAAcC,MCxK/C,SAAgBwB,EAAYC,EAAWC,EAAGC,EAAI,IAC5C,MAAO,IAAMF,IAAcC,EAAIC,EAI1B,SAASC,EAAYC,EAAQxD,GAClC,MAAMa,EAAM,IAAI7C,IAChB,MAAO,KACL,MAAMyF,GAAuB,mBAAXD,EAAwBA,IAAWA,IAAW,GAChE3C,EAAIN,QAAQmD,IACVA,EAAchB,MAAQ,IAExB,MAAMiB,EAAgBrE,OAAO0B,QAAQyC,GAAG5C,IAAI,EAAEzE,EAAMC,MAC7CwE,EAAI/D,IAAIT,IACXwE,EAAIzB,IAAI/C,EAAO,CAAEqG,MAAO,EAAG9E,OAAQ,KAErC,MAAM8F,EAAgB7C,EAAIlC,IAAItC,GAI9B,OAHIqH,EAAc9F,OAAOrC,QAAUmI,EAAchB,OAC/CgB,EAAc9F,OAAOlC,KAAKsE,EAAE3D,EAAOD,IAE9BsH,EAAc9F,OAAO8F,EAAchB,WAU5C,OAPA7B,EAAIN,QAAQ,CAACmD,EAAejF,KACtBiF,EAAchB,MAChBgB,EAAc9F,OAAOgG,OAAOF,EAAchB,OAE1C7B,EAAI5B,OAAOR,KAGRkF,GAIJ,SAASE,EAAWC,EAAY9D,GACrC,MAAMa,EAAM,IAAI7C,IAChB,MAAO,KACL,MAAM+F,EAAOD,IAIb,OAHKjD,EAAI/D,IAAIiH,IACXlD,EAAIzB,IAAI2E,EAAM/D,EAAE+D,IAEXlD,EAAIlC,IAAIoF,IAIZ,SAASC,EAAmB1D,EAAM,IACvC,OAAOhB,OAAO0B,QAAQV,GAAKO,IAAI,EAAEzE,EAAMC,KAAW,GAAGD,MAASC,MAAUZ,KAAK"}